using Foundation;
using UIKit;
using MobileConnectSdk.iOS.Bindings;
using System.Threading.Tasks;
using System;

namespace mobileconnectsdksample_xamarin
{
    // The UIApplicationDelegate for the application. This class is responsible for launching the
    // User Interface of the application, as well as listening (and optionally responding) to application events from iOS.
    [Register("AppDelegate")]
    public class AppDelegate : UIResponder, IUIApplicationDelegate
    {
        readonly MobileAccess _mobileAccess;

        public AppDelegate() : base()
        {
            // *********************************************************************************
            // Configure the Mobile Connect SDK before we start
            // *********************************************************************************

            // Note to developer: If you want to customise messages generated by the SDK, pass a MobileAccessLocalization struct to configure here
            _mobileAccess = MobileAccessProvider.ConfigureWithDatabaseFilePath(null, null, CloudTlsValidationMode.AnyValidCertificateRequired, 0);
        }

        [Export("window")]
        public UIWindow Window { get; set; }

        [Export("application:didFinishLaunchingWithOptions:")]
        public bool FinishedLaunching(UIApplication application, NSDictionary launchOptions)
        {
            // *********************************************************************************
            // Now that the SDK is configured, tell it to start scanning for readers

            // for sample purposes, extended background scanning is off by default. Uncomment the line below to enable it
            // enableExtendedBackgroundScanning()

            // Automatic access is disabled by default. Set isAutomaticAccessEnabled = false to turn it off later if you would like
            _mobileAccess.IsAutomaticAccessEnabled = true;

            // now start scanning for readers
            _mobileAccess.SetScanning(true);

            _ = RegisterMyCredential();
            return true;
        }

        // uses the binding extension methods to do this in a much more idiomatic way
        public async Task RegisterMyCredential()
        {
            if (!(_mobileAccess.ResolveInvitationUrl("https://commandcentre-ap-southeast-2.security.gallagher.cloud", "abc-123") is NSUrl url))
            {
                Console.WriteLine("Can't resolve invitation URL");
                return;
            }

            try
            {
                var credential = await _mobileAccess.RegisterCredential(url, selector => selector(true, SecondFactorAuthenticationType.FingerprintOrFaceId));
                Console.WriteLine("Registered credential {0}", credential.Id);
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex);
            }
        }

        // UISceneSession Lifecycle

        [Export("application:configurationForConnectingSceneSession:options:")]
        public UISceneConfiguration GetConfiguration(UIApplication application, UISceneSession connectingSceneSession, UISceneConnectionOptions options)
        {
            // Called when a new scene session is being created.
            // Use this method to select a configuration to create the new scene with.
            return UISceneConfiguration.Create("Default Configuration", connectingSceneSession.Role);
        }

        [Export("application:didDiscardSceneSessions:")]
        public void DidDiscardSceneSessions(UIApplication application, NSSet<UISceneSession> sceneSessions)
        {
            // Called when the user discards a scene session.
            // If any sessions were discarded while the application was not running, this will be called shortly after `FinishedLaunching`.
            // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
        }
    }
}

